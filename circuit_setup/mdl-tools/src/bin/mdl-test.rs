// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

// This program parses a CBOR-encoded mDL and tests extracting the required information
// to generate the ZK circuit inputs.
//
// Usage:
//    mdl-test --mdl <mdl>
// where
//    <mdl> is a CBOR-encoded mDL
//
// Notes:
//    - The mDL file can be generated by the mdl-gen program
//    - To test: cargo run --bin mdl-test -- --mdl ../inputs/mdl1/mdl.cbor

use clap::Parser;
use coset::Label;
use isomdl::cbor;
use isomdl::definitions::x509::x5chain::X5CHAIN_COSE_HEADER_LABEL;
use isomdl::definitions::x509::X5Chain;
use isomdl::issuance::mdoc::Mdoc;
use p256::ecdsa::{Signature, VerifyingKey};
use p256::pkcs8::EncodePublicKey;
use p256::NistP256;

static MDL_DOCTYPE: &str = "org.iso.18013.5.1.mDL";
static ISO_MDL_NAMESPACE: &str = "org.iso.18013.5.1";
static AAMVA_MDL_NAMESPACE: &str = "org.iso.18013.5.1.aamva";

#[derive(Parser, Debug)]
#[command(author, version, about)]
struct Args {
    /// JSON file containing the mDL ISO claims
    #[arg(short = 'm', long = "mdl")]
    mdl: String,
}

fn main() {
    let args = Args::parse();

    let mdl_cbor = std::fs::read(&args.mdl).unwrap();
    let mdoc = cbor::from_slice::<Mdoc>(&mdl_cbor)
        .map_err(|_| "Failed to parse mDL")
        .unwrap();

    let doc_type = mdoc.doc_type;
    println!("doc_type: {}\n", doc_type);
    if doc_type != MDL_DOCTYPE {
        panic!("Invalid mDL doc type: {}", doc_type);
    }
    
    // TODO: anything to do with the MSO?
    let _mso = mdoc.mso;

    let namespaces = mdoc.namespaces;
    // print all namespaces
    for (key, value) in namespaces.iter() {
        println!("Namespace: {}", key);
        if key != ISO_MDL_NAMESPACE && key != AAMVA_MDL_NAMESPACE {
            panic!("Invalid mDL namespace: {}", key);
        }
        println!("Claim count: {}\n", value.len());
    }
    
    let issuer_auth = mdoc.issuer_auth;

    // isuser_auth fields
    let unprotected_header = issuer_auth.unprotected.clone();
    let x5chain = unprotected_header
        .rest
        .iter()
        .find(|(label, _)| label == &Label::Int(X5CHAIN_COSE_HEADER_LABEL))
        .map(|(_, value)| value.to_owned())
        .map(X5Chain::from_cbor)
        .unwrap()
        .unwrap();

    let issuer_pub_key = x5chain.end_entity_public_key::<NistP256>().unwrap();
    println!("issuer_pub_key: {:?}\n", issuer_pub_key);
    let pem = issuer_pub_key
        .to_public_key_pem(Default::default())
        .unwrap();
    println!("PEM formatted public key:\n{}\n", pem);

    // per mDL spec, aad is empty
    let empty_aad = Vec::<u8>::new();
    let tbs_data = issuer_auth.inner.tbs_data(&empty_aad);
    println!("tbs_data length: {:?}\n", tbs_data.len());

    let signature_bytes = issuer_auth.signature.clone();
    let signature_len = signature_bytes.len();
    println!(
        "signature ({} bytes):\n{:?}\n",
        signature_len, signature_bytes
    );

    let verification_result /* : cose::sign1::VerificationResult */ =
            issuer_auth
            .verify::<VerifyingKey, Signature>(&issuer_pub_key, None, None);
    println!(
        "mDL signature verification result: {:?}\n",
        verification_result
    );
}
