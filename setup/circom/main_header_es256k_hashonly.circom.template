pragma circom 2.1.6;

include "./utils_ecdsa/jwt_ecdsa.circom";
include "./circomlib/circuits/comparators.circom";
include "./circomlib/circuits/gates.circom";
include "./match_claim.circom";
include "./predicates.circom";

template Main(max_msg_bytes, max_json_bytes, field_byte_len, n, k) {

    // #################### JWT signature verification ####################

    signal input message[max_msg_bytes]; // header + . + payload
    signal input digest_248;

    signal input message_padded_bytes; // length of the message including the padding
    signal input period_idx; // index of the period in the base64 encoded msg

    component jwt_verify = JWTHashOnlyES256K(max_msg_bytes, max_json_bytes, n, k);
    jwt_verify.message <== message;
    jwt_verify.message_padded_bytes <== message_padded_bytes;    
    jwt_verify.period_idx <== period_idx;

    // Truncate last 8 bits of the 256-bit digest to get a 248-bit digest
    component truncate = Truncate(256, 248);
    truncate.inputs <== jwt_verify.digest;

    // Convert the 248-bit digest to an integer
    component bits_to_limbs = BitsToLimbs(248, 1);
    bits_to_limbs.bits <== truncate.outputs;

    // Ensure the 248-bit hash as an integer we computed is the same as the prover's input
    component is_equal = IsEqual();
    is_equal.in[0] <== digest_248;
    is_equal.in[1] <== bits_to_limbs.limbs[0];
    is_equal.out === 1;

    signal jwt_bytes[max_json_bytes];
    jwt_bytes <== jwt_verify.jwt_bytes;

    // #################### JWT claim predicates ####################

    // Compute the nested level of each position.
    component is_curly_bracket_l[max_json_bytes];
    component is_curly_bracket_r[max_json_bytes];
    signal object_nested_level[max_json_bytes + 1];
    object_nested_level[0] <== 0;
    for (var i = 0; i < max_json_bytes; i++) {
        is_curly_bracket_l[i] = IsZero();
        is_curly_bracket_r[i] = IsZero();
        is_curly_bracket_l[i].in <== jwt_bytes[i] - 123;
        is_curly_bracket_r[i].in <== jwt_bytes[i] - 125;
        object_nested_level[i + 1] <== object_nested_level[i] + is_curly_bracket_l[i].out - is_curly_bracket_r[i].out;
    }